# Coding Style Rules

## Documentation and Communication
- **No diagrams**: Do not create Mermaid diagrams unless explicitly requested
- **Concise summaries**: Keep explanations brief and focused
- **No verbose documentation**: Avoid lengthy explanations of obvious concepts

## Code Comments
- **Minimal commenting**: Only comment tricky or non-obvious code
- **No redundant comments**: Don't explain what the code obviously does
- **Focus on why, not what**: When commenting, explain reasoning rather than mechanics

## Code Duplication Elimination
- **Use template metaprogramming**: Eliminate duplication with templates rather than copying similar classes
- **Template parameters for behavior**: When applicable use bool template parameters to control const/non-const variants
- **Type aliases for clean APIs**: Provide familiar names while using unified implementations
- **Follow standard library patterns**: Use patterns like `std::conditional_t` and SFINAE for type safety
- **Single source of truth**: Maintain logic in one place to reduce maintenance burden

## Control Flow and Nesting
- **Prefer early exits**: Use guard clauses and early returns to minimize nesting
- **Avoid deep conditionals**: Keep the main logic at the top level rather than buried in if statements
- **Handle edge cases first**: Deal with special cases early and return, leaving the main path unindented
- **Linear flow**: Structure code so the primary logic flows top-to-bottom without deep nesting

## Examples

### ❌ Bad (over-commented):
```cpp
// Increment the size member variable
++m_size;

// Loop through all elements
for (size_t i = 0; i < m_size; ++i) {
    // Calculate the physical index
    size_t physical_idx = add_index(m_tail, i);
}
```

### ✅ Good (minimal comments):
```cpp
++m_size;

for (size_t i = 0; i < m_size; ++i) {
    size_t physical_idx = add_index(m_tail, i);
    // Power-of-2 optimization uses bit masking for faster index calculation
    if constexpr ((Capacity & (Capacity - 1)) == 0) {
        physical_idx = (m_tail + i) & (Capacity - 1);
    }
}
```

### ❌ Bad (duplicated iterator classes):
```cpp
class iterator {
    T* current_;
    // ... 50 lines of iterator implementation
};

class const_iterator {
    const T* current_;
    // ... 50 lines of nearly identical iterator implementation
};
```

### ✅ Good (unified template implementation):
```cpp
template<bool IsConst>
class iterator_impl {
    using pointer = std::conditional_t<IsConst, const T*, T*>;
    using reference = std::conditional_t<IsConst, const T&, T&>;
    
    pointer current_;
    // ... single implementation that works for both cases
    
    // Allow non-const to const conversion
    template<bool OtherIsConst, typename = std::enable_if_t<IsConst && !OtherIsConst>>
    iterator_impl(const iterator_impl<OtherIsConst>& other) : current_(other.current_) {}
};

// Clean API through type aliases
using iterator = iterator_impl<false>;
using const_iterator = iterator_impl<true>;
```

### ❌ Bad (deep nesting):
```cpp
insert_result push_back_impl(U&& value)
{
    if constexpr (Policy == overflow_policy::discard) {
        if (full()) {
            return insert_result::discarded;
        } else {
            // Insert normally
            T* storage = get_storage();
            dod::construct<T>(&storage[m_head], std::forward<U>(value));
            m_head = next_index(m_head);
            ++m_size;
            return insert_result::inserted;
        }
    } else {
        // Overwrite policy implementation
        if (full()) {
            // ... overwrite logic
        } else {
            // ... normal insert logic
        }
    }
}
```

### ✅ Good (early exit, linear flow):
```cpp
template<typename U>
insert_result push_back_impl(U&& value)
{
    if constexpr (Policy == overflow_policy::discard) {
        if (full()) {
            return insert_result::discarded;
        }
    }

    bool was_full = full();
    T* storage = get_storage();

    if (was_full) {
        // Overwrite mode: reuse existing slot
        CIRCULAR_BUFFER_ASSERT(Policy == overflow_policy::overwrite);
        dod::reconstruct(&storage[m_head], std::forward<U>(value));
        m_head = next_index(m_head);
        m_tail = next_index(m_tail);
        return insert_result::overwritten;
    }

    // Normal insertion
    dod::construct<T>(&storage[m_head], std::forward<U>(value));
    m_head = next_index(m_head);
    ++m_size;
    return insert_result::inserted;
}
```
description:
globs:
alwaysApply: false
---
