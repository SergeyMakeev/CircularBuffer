# Comment Writing Style Rules

## Comment Block Format
- **Use `/* */` for multi-line comments** instead of Doxygen `/** */`
- **Use `**bold text**` for headings and important concepts**
- **Add blank lines within comments for visual separation**
- **Remove formal documentation tags** like `@brief`, `@tparam`, `@code`
- **Write comments in natural, conversational style**

## Comment Content Guidelines
- **Explain design rationale and trade-offs** rather than just describing what code does
- **Include performance implications** when relevant
- **Mention limitations and constraints** of the implementation
- **Explain use cases and ideal scenarios** for the code
- **Focus on "why" decisions were made** rather than mechanical "what"

## Assertion Comments
- **Place assertion explanations directly above the assertion**
- **Explain what condition is being checked and why it should be true**
- **Provide context about the invariant being maintained**

## Visual Formatting in Comments
- **Use ASCII art for diagrams with proper spacing**:
  ```cpp
  // 
  //   Empty: head == tail, size == 0
  //   Full:  head == tail, size == Capacity
  //   Partial: head != tail, 0 < size < Capacity
  // 
  ```
- **Group related comments with blank line separation**
- **Prefer comments above code rather than trailing comments**

## Examples

### ✅ Good Comment Style:
```cpp
/*

**High-performance circular buffer implementation**

A fixed-capacity circular buffer that stores exactly N elements without the N-1 limitation.
Uses separate head/tail/size tracking for full capacity utilization.

This design avoids dynamic memory allocation and provides O(1) push/pop operations.
The buffer supports both embedded storage (for small buffers) and heap storage (for large buffers).

Ideal for performance-critical systems where memory layout and control matter.
The main limitation is fixed capacity - no dynamic resizing is supported.

*/

// Ensure index is within valid range for the buffer capacity
CIRCULAR_BUFFER_ASSERT(index < Capacity);

// Power-of-2 optimization: use bit masking instead of expensive modulo operation
// This provides significant performance improvement for capacities that are powers of 2
if constexpr ((Capacity & (Capacity - 1)) == 0) {
    return (index + 1) & (Capacity - 1);
}
```

### ❌ Avoid This Style:
```cpp
/**
 * @brief High-performance circular buffer
 * @tparam T Element type
 * @tparam Capacity Buffer size
 */

CIRCULAR_BUFFER_ASSERT(index < Capacity); // Check index bounds
```

## When to Comment
- **Complex algorithms** requiring explanation
- **Design decisions** that aren't obvious from code
- **Performance optimizations** and their rationale
- **Safety invariants** and why assertions exist
- **Non-obvious constraints** or requirements
- **Template metaprogramming** techniques
- **Memory management** strategies

## When NOT to Comment
- **Obvious operations** like simple assignments
- **Standard container operations** that are self-explanatory  
- **Trivial getters/setters**
- **Simple loop iterations**
- **Basic arithmetic** unless it represents something non-obvious

## Specific Patterns for Circular Buffer

### Class/Function Documentation
```cpp
/*

**Function Name**

Brief description of what it does and why it exists.

Explanation of design decisions, trade-offs, and constraints.
Include performance characteristics and ideal use cases.
Mention any limitations or caveats.

*/
```

### Template Parameter Documentation
```cpp
/*

**Template Parameters**

T: Element type - must be copy/move constructible
Capacity: Fixed buffer size - must be > 0 and fit in IndexType
IndexType: Type for indices and sizes - determines maximum capacity
Alignment: Memory alignment for storage - must be power of 2
EmbeddedThreshold: Cutoff for embedded vs heap storage
Policy: Overflow behavior - overwrite or discard

*/
```

### Performance Critical Code
```cpp
// Cache-friendly: process elements page by page to improve locality
// This minimizes cache misses when working with large buffers
for (size_t page = 0; page < page_count; ++page) {
    // ... process page
}

// Branch prediction optimization: handle common case first
if (likely(!full())) {
    // Fast path: normal insertion
} else {
    // Slow path: handle overflow according to policy
}
```

### Storage Strategy Comments
```cpp
// Storage strategy selection based on capacity and threshold
// Embedded storage: better cache locality, zero allocation overhead
// Heap storage: avoids large stack objects, single allocation at construction
static constexpr bool uses_embedded_storage = (Capacity <= EmbeddedThreshold);
```

## Comment Placement Rules
- **Above the code** rather than at the end of lines
- **Group related explanations** with blank lines for separation
- **Explain before showing** - context first, then implementation
description:
globs:
alwaysApply: false
---
